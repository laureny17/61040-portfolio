# Problem Set 2

## Concept Questions

1. **Contexts.** The _NonceGeneration_ concept ensures that the short strings it generates will be unique and not result in conflicts. What are the contexts for, and what will a context end up being in the URL shortening app?

   > Contexts are for defining the larger score within which we are generating the unique strings for. Considering the context within _NonceGeneration_ allows us to define the behavior so that the strings only have to be unique within the context it is given in. The context will end up being the domain in the URL shortening app. This means that, for instance, if we are generating shortened URLs for domains/contexts A and B, the unique strings generated by _NonceGeneration_ can be the same between strings generated for context A versus B, but for two strings generated for the same context, they will be different.

2. **Storing used strings.** Why must the _NonceGeneration_ store sets of used strings? One simple way to implement the _NonceGeneration_ is to maintain a counter for each context and increment it every time the generate action is called. In this case, how is the set of used strings in the specification related to the counter in the implementation? (In abstract data type lingo, this is asking you to describe an abstraction function.)

   > Since each generate must return a string not returned before for that context, _NonceGeneration_ must store sets of used strings to keep track of strings that have already been returned for each context. If we maintain a counter for each context and increment it each time the generate action is called, then in the implementation, the set of used strings would relate to the counter because each string would be an encoding from each number (from the initial counter value up to and exclusive of the current counter value) to some unique string.

3. **Words as nonces.** One option for nonce generation is to use common dictionary words (in the style of [yellkey.com](https://yellkey.com), for example) resulting in more easily remembered shortenings. What is one advantage and one disadvantage of this scheme, both from the perspective of the user? How would you modify the _NonceGeneration_ concept to realize this idea?

   > From the perspective of the user, one advantage of this scheme is that the shortening would be very readable and easy to remember compared to a string of random characters. However, one disadvantage would be that using common dictionary words can make links easier to guess (and therefore less secure), and also limits the number of total shortenings that can exist at once (which means that if our service is used by a large number of users, we may have to limit the lifespan of a shortened URL so that we can recycle words to be used again by other users). To realize this idea, I would modify the _NonceGeneration_ concept by adding to the state a `dictionary set of Strings`

## Synchronization Questions

1. **Partial matching.** In the first sync (called _generate_), the _Request.shortenUrl_ action in the when clause includes the shortUrlBase argument but not the targetUrl argument. In the second sync (called register) both appear. Why is this?

   > _generate_ only only needs the URL base in order to generate the unique string for shortening, as the context/domain is needed to create a unique string that hasn't yet been used for that context/domain. In contrast, _register_ needs both the shortUrlBase and targetUrl argument because it creates the mapping from the shortened URL to the target URL.

2. **Omitting names.** The convention that allows names to be omitted when argument or result names are the same as their variable names is convenient and allows for a more succinct specification. Why isn’t this convention used in every case?

   > This convention is only used when the argument or result name is the same as the variable name; otherwise, the specification could lead to confusion, because if they don't match, then omitting the name removes a detail that is important for understanding the specification.

3. **Inclusion of request.** Why is the _request_ action included in the first two syncs but not the third one?

   > The _request_ action is included in the first two syncs but not the third one because _setExpiry_ should not automatically follow the completion of a request; we want to ensure that the URL is registered first, and then follow that up with setting the expiry time.

4. **Fixed domain.** Suppose the application did not support alternative domain names, and always used a fixed one such as “bit.ly.” How would you change the synchronizations to implement this?

   > If the application does not support alternative domain names, then shortUrlBase can be fixed. We can change the syncs as follows:
   >
   > ```
   > sync generate
   > when Request.shortenUrl (shortUrlBase: "bit.ly")
   > then NonceGeneration.generate (context: "bit.ly")
   > ```
   >
   > ```
   > sync register
   > when
   >    Request.shortenUrl (targetUrl, shortUrlBase: "bit.ly")
   >    NonceGeneration.generate (): (nonce)
   > then UrlShortening.register (shortUrlSuffix: nonce, shortUrlBase: "bit.ly", targetUrl)
   > ```

5. **Adding a sync.** These synchronizations are not complete; in particular, they don’t do anything when a resource expires. Write a sync for this case, using appropriate actions from the _ExpiringResource_ and _URLShortening_ concepts.

   > We can add a sync that deletes the short URL and its association with the target URL as follows:
   >
   > ```
   > sync expireURL
   > when ExpiringResource.expireResource (): (resource)
   > then UrlShortening.delete (shortUrl: resource)
   > ```

## Extending the design

1. Design a couple of additional concepts to realize this extension, and write them out in full (but including only the essential actions and state). It should not be necessary to make any changes to the existing concepts.

2. Specify three essential synchronizations with your new concepts: one that happens when shortenings are created; one when shortenings are translated to targets; and one when a user examines analytics.

```
concept UrlAnalytics
purpose Maintain an access counter for short URLs
principle
    When a short URL is created, its counter starts at 0, and each access of the short URL
    increments the counter; reading returns the current count
state
    a set of Counters with
        shortUrl String
        accesses Number
actions
    init (shortUrl: String)
        requires: shortUrl is a registered short URL associated with a target URL
        effect: if no counter exists for shortUrl, create one with accesses = 0; otherwise, reset the counter's accesses to 0
    record (shortUrl: String)
        requires: counter exists
        effect: increment accesses by 1
    read (shortUrl: String): (accesses: Number)
        requires: counter exists
        effect: return accesses
```

```
concept UrlOwnership
purpose Keep track of which user owns which shortUrl resource to create a way for certain actions to be limited for only the owner to perform
principle
    A user can be associated with a short URL as its owner, so when a user tries to perform a owner-only restricted action, they must first be verified as the owner
state
    a set of Ownerships with
        resource Resource
        owner User
actions
    assignOwner (resource: Resource, owner: User)
        requires: resource has no owner
        effect: binds resource to the user provided, owner
    checkIfOwner (resource: Resource, user: User)
        requires: resource has an owner
        effect: completes if the given user is the owner of the resource
```

```
sync setupAnalytics
when
    Request.shortenUrl (user)
    UrlShortening.register(): (shortUrl)
then
    UrlAnalytics.init (shortUrl)
    UrlOwnership.assignOwner (resource: shortUrl, owner: user)

```

```
sync countOnLookup
when UrlShortening.lookup(shortUrl): (targetUrl)
then UrlAnalytics.record(shortUrl)
```

```
sync readAnalytics
when
    Request.viewAnalytics (shortUrl, user)
    UrlOwnership.checkIfOwner (resource: shortUrl, user: user)
then
    UrlAnalytics.read (shortUrl): (accesses)
```

3. As a way to assess the modularity of your solution, consider each of the following feature requests, to be included along with analytics. For each one, outline how it might be realized (eg, by changing or adding a concept or a sync), or argue that the feature would be undesirable and should not be included:

   - Allowing users to choose their own short URLs

     > We can change _NonceGeneration_ to have a new action:
     >
     > ```
     > chooseCustomUrl (context: String, chosenNonce: String): (nonce: String)
     >      requires: chosenNonce does not already exist as a shortening in the provided context
     >      effect: add chosenNonce to the used set for the provided context, and return the nonce
     > ```
     >
     > ... and add a new sync that works as an alternative to register when users provide their own chosen input for the short URL:
     >
     > ```
     > sync customRegister
     > when Request.shortenUrl (targetUrl, shortUrlBase, user, chosenNonce)
     >      NonceGeneration.chooseCustomUrl (context: shortUrlBase, chosenNonce: chosenNonce): (nonce)
     > then UrlShortening.register (shortUrlBase, chosenNonce: nonce, targetUrl): (shortUrl)
     >      UrlAnalytics.init (shortUrl)
     >      UrlOwnership.assignOwner (resource: shortUrl, owner: user)
     > ```

   - Using the “word as nonce” strategy to generate more memorable short URLs
     > We can change _NonceGeneration_'s `generate` action to draw strings from a dictionary of existing words, which can be a part of _NonceGeneration_'s state.
   - Including the target URL in analytics, so that lookups of different short URLs can be grouped together when they refer to the same target URL
     > We do not need to add this feature. Though multiple short URLs technically can link to the same target URL, it's unnecessary to have more than one short URL for the same target URL. Also, grouping short URLs complicates the idea of ownership (who should be the one(s) to have access to the analytics for the entire group, if each short URL has its own owner?).
   - Generate short URLs that are not easily guessed
     > We can change _NonceGeneration_'s generate action to generate a unique string, but if the generated string happens to match a string that is in a dictionary of existing words, continually regenerate until a string that doesn't exist in the dictionary is generated.
   - Supporting reporting of analytics to creators of short URLs who have not registered as user
     > We do not need to add this feature. If we wanted to support reporting of analytics of creators of short URLs who have not registered as a user, we would still need some sort of way to authenticate non-user creator as owners of short URLs. Authentication for a non-registered user (e.g. through passwords/tokens) is less secure, since it's harder to recover, revoke, and keep track of who is using the credential.
